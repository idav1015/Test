// Installable onEdit trigger function
function installableOnEdit(e) {
  const sheet = e.source.getActiveSheet(); // Get active sheet
  const range = e.range; //range of active cell
  const editedRange = e.range;
  const col = editedRange.getColumn();
  const startRow = range.getRow(); //row edited range starts
  const startCol = range.getColumn(); //column edited range starts
  const numRows = range.getNumRows(); //total rows in edited range
  
  // Convert to uppercase if edited in columns A, D, or E
  if ([1, 4, 5].includes(col)) {
    convertToUppercase(sheet, editedRange);
  }

  // Check if the edited cell is in column A
  if (col === 1) {
    const duplicateRanges = getDuplicateRanges(sheet);

    markDuplicates(sheet, duplicateRanges);
    validateLabels(sheet, duplicateRanges);
    updateAllLabels(sheet, duplicateRanges);
  }

  if (startRow != 1 && startCol < 6) {
    const timeStamp = new Date();
    const modifiedBy = Session.getActiveUser().getEmail();

    for (let row = 0; row < numRows; row++) {
      sheet.getRange(startRow + row, 6).setValue(timeStamp);
      sheet.getRange(startRow + row, 7).setValue(modifiedBy);
    }
  }

  columnsFilled(sheet);
}

// Helper function to determine the label and color based on the format of the cell value
function getLabelAndColor(cellValue) {
  let label;
  let color = "white";

  if (cellValue === "") {
    label = "";
    color = "white";
  } else if (/^CR [A-Za-z0-9]+-[0-9]{2,}$/.test(cellValue)) {
    label = "Access";
  } else if (/^CAM [A-Za-z0-9]+-[0-9]{2,}$/.test(cellValue)) {
    label = "CCTV";
  } else if (/^I [A-Za-z0-9]+-[0-9]{2,}$/.test(cellValue)) {
    label = "Intercom";
  } else if (/^M [A-Za-z0-9]+-[0-9]{2,}$/.test(cellValue)) {
    label = "Monitor Point";
  } else {
    label = "INCORRECT LABEL";
    color = "#f9cb9c";
  }

  return { label, color };
}

// Function to clear label and background in column B
function clearLabel(range) {
  const nextCell = range.offset(0, 1); // Cell in column B adjacent to edited cell
  nextCell.clearContent().setBackground("white"); // Clear content and set background to white
  range.setBackground("white"); // Set background of edited cell to white
}

// Function to set the label in the adjacent cell in column B
function setLabel(range) {
  const cellValue = range.getValue().trim(); // Edited cell on column A (trimmed to remove leading/trailing spaces)
  const nextCell = range.offset(0, 1); // Cell adjacent to cellValue on column B

  const { label, color } = getLabelAndColor(cellValue);
  if (label === "") {
    clearLabel(range);
  } else {
    nextCell.setValue(label).setBackground(color); 
    range.setBackground(color);
  }
}

// Function to validate labels and types
function validateLabels(sheet, duplicateRanges) {
  const lastRow = sheet.getLastRow();
  const dataRange = sheet.getRange(2, 1, lastRow - 1, 2); // Range A2:B to the last row
  const dataValues = dataRange.getValues();

  for (let i = 0; i < dataValues.length; i++) {
    const label = dataValues[i][0].trim();
    let currentType = dataValues[i][1].trim();
    const range = sheet.getRange(i + 2, 2); // Column B for the current row (i + 2 because of header row)

    const { label: expectedType, color } = getLabelAndColor(label);

    // Compare current type with expected type and update if necessary
    if (currentType !== expectedType && !duplicateRanges.includes(i + 2)) {
      range.setValue(expectedType).setBackground(color);
    } else if (currentType === expectedType) {
      range.setBackground("white");
    }
  }
}

// Function to get duplicates and return list of ranges
function getDuplicateRanges(sheet) {
  var data = sheet.getRange("A2:A" + sheet.getLastRow()).getValues(); // Get all values in column A
  var duplicateCount = {};
  var duplicateRanges = [];

  // Count occurrences of each non-blank value
  for (var i = 0; i < data.length; i++) {
    var value = data[i][0];
    if (value !== "") {
      if (duplicateCount[value]) {
        duplicateCount[value].count++;
        duplicateCount[value].rows.push(i + 2); // Adjust for header row
      } else {
        duplicateCount[value] = { count: 1, rows: [i + 2] }; // Adjust for header row
      }
    }
  }

  // Collect ranges of duplicates
  for (var key in duplicateCount) {
    if (duplicateCount[key].count > 1) {
      duplicateRanges = duplicateRanges.concat(duplicateCount[key].rows);
    }
  }

  return duplicateRanges;
}

// Function to update labels in column B only if necessary
function updateAllLabels(sheet, duplicateRanges) {
  const lastRow = sheet.getLastRow();
  const dataRange = sheet.getRange(2, 1, lastRow - 1, 2); // Range A2:B to the last row
  const dataValues = dataRange.getValues();

  for (let i = 0; i < dataValues.length; i++) {
    const label = dataValues[i][0].trim();
    let currentType = dataValues[i][1].trim();
    const range = sheet.getRange(i + 2, 2); // Column B for the current row (i + 2 because of header row)

    const { label: expectedType, color } = getLabelAndColor(label);

    if (currentType !== expectedType && !duplicateRanges.includes(i + 2)) {
      range.setValue(expectedType).setBackground(color);
    } else if (currentType === expectedType && range.getBackground() !== color) {
      range.setBackground(color);
    }
  }
}

// Function to check if a cell is not in the list of duplicate ranges
function isNotDuplicate(range, duplicateRanges) {
  return !duplicateRanges.includes(range.getRow());
}

// Function to mark duplicates in column B based on the list of ranges
function markDuplicates(sheet, duplicateRanges) {
  const dataRange = sheet.getRange("A2:B" + sheet.getLastRow()); // Get range A2:B to the last row
  const dataValues = dataRange.getValues();

  for (let i = 0; i < dataValues.length; i++) {
    const row = i + 2; // Adjust for header row
    const cellA = dataValues[i][0];
    const cellB = dataValues[i][1];
    const value = "DUPLICATE LABEL";
    
    if (cellA !== "" && duplicateRanges.includes(row)) {
      // Set background to red for duplicated labels
      sheet.getRange("B" + row).setValue(value).setBackground("#ea9999");
    } else {
      // Clear content and set background to white for non-duplicated labels
      sheet.getRange("B" + row).clearContent().setBackground("white");
    }
  }
}

// Function to apply conditional formatting to columns based on column A values
function columnsFilled(sheet) {
  const data = sheet.getRange("A2:A" + sheet.getLastRow()).getValues();

  for (let row = 0; row < data.length; row++) {
    const valueA = data[row][0];
    const rowIndex = row + 2; // header row
    const cells = [
      sheet.getRange("A" + rowIndex),
      sheet.getRange("B" + rowIndex),
      sheet.getRange("C" + rowIndex),
      sheet.getRange("D" + rowIndex),
      sheet.getRange("E" + rowIndex),
    ];

    // If cell in column A is empty, set cells from columns A & B to white
    if (!valueA) {
      cells[0].setBackground("white");
      cells[1].setBackground("white");
    }

    updateCellBackgroundAndNote(cells[2], valueA, "Please change status", "#f9cb9c"); // calls updateCellBackgroundAndNote Function and applies format based on value of column A for column C
    updateCellBackgroundAndNote(cells[3], valueA, "Please add Project Name (CDRXXXXX)", "#f9cb9c"); // calls updateCellBackgroundAndNote Function and applies format based on value of column A for column D
    updateCellBackgroundAndNote(cells[4], valueA, "Please add equipment zone", "#f9cb9c"); // calls updateCellBackgroundAndNote Function and applies format based on value of column A for column E
  }
}

// Function to update the background and note of a cell based on a condition
function updateCellBackgroundAndNote(cell, condition, note, background) {
  if (!condition) {
    cell.setBackground("white").setNote(""); // clears background and note
  } else if (cell.getValue() === "") {
    cell.setBackground(background).setNote(note); // sets background and note
  } else {
    cell.setBackground("white").setNote(""); // clears background and note
  }
}

// Function to convert values in a range to uppercase
function convertToUppercase(sheet, range) {
  const values = range.getValues();
  for (let i = 0; i < values.length; i++) {
    for (let j = 0; j < values[i].length; j++) {
      values[i][j] = values[i][j].toString().toUpperCase();
    }
  }
  range.setValues(values);
}
